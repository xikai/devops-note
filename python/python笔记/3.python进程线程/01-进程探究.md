### 进程探究
* 程序：磁盘上的可执行二进制文件，并无运行状态
* 进程：这是一个在内存中运行的任务实例

---

* Linux下进程属性：
  * 进程拥有自己独立的PID（身份证号）
    * 0 ~ 65535 PID是有限的 
    * 当你一台Linux有了超过65535个进程，第65536个进程 无法启动！
  * 独立的内存空间，独立的地址。
  * PID：
    * 0：这个进程是真正的调度进程(idle进程)，是系统初始化的第一个进程，是所有其他进程的祖先！
    * 1：这个进程是Init进程，后续的系统启动，由0进程创建，第一个子进程，完成剩余的系统引导工作。
    * 2：线程/进程 管理进程
  * PCB控制块 process control block 
    * 进程PCB是用来管理进程，维护进程属性的一个数据块
    * 记录进程中的属性特征，进程的运行状态
    * 没有合法PCB的进程，不会被操作系统所识别管理
  * PCB进程控制块中主要有以下：
    * 进程标识符 PID。
    * 调度信息：进程优先级
    * 进程状态：挂起，就绪，执行，中断，僵尸。
    * 进程使用的内存空间：文件，套接字（socket），网卡，硬件设备。
    * 处理器信息：计数器，寄存器，指针。
 
---
 
  * 进程的状态：
    * **R**：就绪/运行 READY RUNNING
      * 实际在CPU上运行的进程，可以被称作运行状态
      * 接下来要执行的进程，处于就绪状态，那么也会被称作R
    * **S**：可中断睡眠状态
      * 进程去等待资源，等待别人链接，等待读取文件内容，等待打开硬件设备，CPU资源不够用
      * 等待的进程，有专门的任务队列维护，通过一定的事件可以重新激活这些进程进入运行状态R
    * D：不可中断睡眠状态
      * 一般是一些内核进程，Kill -9无法直接杀死，并且无法直接唤醒
      * 这样的进程也处于睡眠状态
      * 这种睡眠状态是为了保护一些硬件资源，保护一些设备。
    * T：暂停状态
      * 调试程序，打断点
    * X：停止状态
    * **Z**：进程在退出时，必须要经过**僵尸状态**。
      * 每个进程在退出的时候，都会释放掉内存，但是如果父进程并没有对他做PCB释放，
      * 这个PCB进程控制块就会保留下来，会一致占用PID
 
---
 
 * 僵尸进程：
   * 父进程创建子进程，但是并没有及时回收工作完毕的子进程
   * 没有被释放资源的子进程就会被称作僵尸进程
   * 在于PCB进程控制块无法及时得到释放，所以会导致无法创建新的进程，占用了PID资源。
   * 注意：开发者要注意回收僵尸进程，没人会帮你释放僵尸进程。
   ```
   #僵尸进程：父进程不及时回收子进程
    import os
    import time
    re_fork = os.fork()
     
    if re_fork == 0:
        #这个是子进程
        print("子进程:",os.getpid())
        time.sleep(10)
        print("子进程结束!")
    else:
        #父进程
        #re_fork : 子进程的PID
        print('父进程:',os.getpid())
        time.sleep(30) #只要父进程的运行时间大于子进程并且不做回收，就可以实现僵尸进程！
        print("父进程结束!")
    #父进程几秒结束？ 5秒之后结束 他要等待你的孩子玩耍尽兴了，并且回收了，我父进程才会结束
     
    #子进程15秒结束
    #父进程30秒才结束
        #在子进程结束之后，父进程不回收，不管
        #僵尸进程就出现了
   ```
 
* 孤儿进程：
  * 父进程先结束了
  * 还在执行的子进程没人管了。
  * 孤儿进程就由此诞生了
  * 孤儿进程会被INIT进程接管，然后完成之后，INIT进程帮你回收。
  ```
  import os
  import time
  re_fork = os.fork()
   
  if re_fork == 0:
      #子进程:
      time.sleep(10)
  else:
      pass
  #孤儿进程
  #孤儿多长时间: 10S
  ```
 
---
 
* 进程状态下一级别：
  * s：进程的会话负责人
  * <：进程有高优先级
  * N：进程有低优先级
  * l：具备多线程的进程
  * +：位于后台的进程
 
---
* Nice值：Linux进程优先级 整数 
  * 权限：-20 - +19 
  * 数字越小，优先级越高
  * 只有超级用户可有把进程优先级设置为负数
* VSZ：进程占用的虚拟内存大小
* RSS：这个进程占用的固定内存大小
* PRI/NI：进程优先级
* TTY：打开的虚拟终端
* PPID：当前进程的父进程ID
* COMMAND：开启这个进程的命令
* USER：开启进程的用户（表示了当前进程有什么样的权利）
* F：进程旗标(process flag)
  * 进程的权限
  * 4：ROOT权限